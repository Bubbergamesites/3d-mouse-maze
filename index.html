<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Mouse Maze</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  #hud {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 6px;
    font-family: Arial, sans-serif;
    font-size: 14px;
  }
</style>
</head>
<body>
<div id="hud">
  <div id="level">Level: 1</div>
  <div>Find the cheese ðŸ§€</div>
  <div>WASD / Arrows â€¢ R = Reset</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
/* =====================
   BASIC SETUP
===================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* =====================
   LIGHTING
===================== */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 0.8);
sun.position.set(50, 80, 50);
scene.add(sun);

/* =====================
   CONSTANTS
===================== */
const CELL = 10;
let level = 1;
let size = 9;
let maze = [];
let walls = [];
let cheese;

/* =====================
   MOUSE MODEL
===================== */
const mouse = new THREE.Group();

// Body
const body = new THREE.Mesh(
  new THREE.SphereGeometry(2.2, 18, 18),
  new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
);
body.position.y = 2.2;
mouse.add(body);

// Head
const head = new THREE.Mesh(
  new THREE.SphereGeometry(1.6, 16, 16),
  new THREE.MeshStandardMaterial({ color: 0xb5b5b5 })
);
head.position.set(0, 2.4, 2.6);
mouse.add(head);

// Ears
for (let x of [-1, 1]) {
  const ear = new THREE.Mesh(
    new THREE.SphereGeometry(0.7, 12, 12),
    new THREE.MeshStandardMaterial({ color: 0xc0c0c0 })
  );
  ear.position.set(x, 3.6, 2.2);
  mouse.add(ear);
}

// Tail (segmented)
const tail = [];
for (let i = 0; i < 6; i++) {
  const segment = new THREE.Mesh(
    new THREE.SphereGeometry(0.4 - i*0.05, 10, 10),
    new THREE.MeshStandardMaterial({ color: 0x999999 })
  );
  segment.position.set(0, 1.6, -2.2 - i*0.6);
  mouse.add(segment);
  tail.push(segment);
}

scene.add(mouse);

/* =====================
   MAZE GENERATION (DFS)
===================== */
function generateMaze(n) {
  maze = Array.from({length:n}, () =>
    Array.from({length:n}, () => ({v:false, w:[1,1,1,1]}))
  );

  function carve(x,y) {
    maze[y][x].v = true;
    const dirs = [[0,-1,0,2],[1,0,1,3],[0,1,2,0],[-1,0,3,1]];
    dirs.sort(()=>Math.random()-0.5);

    for (let [dx,dy,w1,w2] of dirs) {
      const nx = x+dx, ny = y+dy;
      if (nx>=0 && ny>=0 && nx<n && ny<n && !maze[ny][nx].v) {
        maze[y][x].w[w1] = 0;
        maze[ny][nx].w[w2] = 0;
        carve(nx,ny);
      }
    }
  }
  carve(0,0);
}

/* =====================
   BUILD MAZE
===================== */
function buildMaze() {
  walls.forEach(w=>scene.remove(w));
  walls = [];
  if (cheese) scene.remove(cheese);

  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(size*CELL, size*CELL),
    new THREE.MeshStandardMaterial({ color: 0x444444 })
  );
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  const wallMat = new THREE.MeshStandardMaterial({ color: 0x666666 });

  for (let y=0;y<size;y++) {
    for (let x=0;x<size;x++) {
      const px = x*CELL;
      const pz = y*CELL;
      maze[y][x].w.forEach((w,i)=>{
        if (!w) return;
        const wall = new THREE.Mesh(
          new THREE.BoxGeometry(CELL, 6, 1),
          wallMat
        );
        wall.position.y = 3;
        if (i===0) wall.position.set(px,3,pz-CELL/2);
        if (i===1){ wall.rotation.y=Math.PI/2; wall.position.set(px+CELL/2,3,pz); }
        if (i===2) wall.position.set(px,3,pz+CELL/2);
        if (i===3){ wall.rotation.y=Math.PI/2; wall.position.set(px-CELL/2,3,pz); }
        wall.geometry.computeBoundingBox();
        walls.push(wall);
        scene.add(wall);
      });
    }
  }

  cheese = new THREE.Mesh(
    new THREE.ConeGeometry(2.5,4,16),
    new THREE.MeshStandardMaterial({ color: 0xffdd00 })
  );
  cheese.position.set((size-1)*CELL,2,(size-1)*CELL);
  scene.add(cheese);

  mouse.position.set(0,0,0);
  mouse.rotation.y = 0;
}

/* =====================
   CONTROLS
===================== */
const keys = {};
addEventListener("keydown", e=>{
  keys[e.key.toLowerCase()] = true;
  if (e.key.toLowerCase()==="r") nextLevel(true);
});
addEventListener("keyup", e=>keys[e.key.toLowerCase()] = false);

/* =====================
   COLLISION
===================== */
function collides(pos) {
  const mouseBox = new THREE.Box3().setFromCenterAndSize(
    pos.clone().add(new THREE.Vector3(0,2,0)),
    new THREE.Vector3(3,4,3)
  );
  for (const w of walls) {
    const box = new THREE.Box3().setFromObject(w);
    if (mouseBox.intersectsBox(box)) return true;
  }
  return false;
}

/* =====================
   LEVEL CONTROL
===================== */
function nextLevel(reset=false) {
  if (!reset) level++;
  size = Math.min(15, 7 + level);
  document.getElementById("level").innerText = `Level: ${level}`;
  generateMaze(size);
  buildMaze();
}
nextLevel(true);

/* =====================
   GAME LOOP
===================== */
function animate() {
  requestAnimationFrame(animate);

  if (keys["a"]||keys["arrowleft"]) mouse.rotation.y += 0.05;
  if (keys["d"]||keys["arrowright"]) mouse.rotation.y -= 0.05;

  let move = 0;
  if (keys["w"]||keys["arrowup"]) move = 0.25;
  if (keys["s"]||keys["arrowdown"]) move = -0.25;

  const nextPos = mouse.position.clone();
  nextPos.x += Math.sin(mouse.rotation.y)*move;
  nextPos.z += Math.cos(mouse.rotation.y)*move;

  if (!collides(nextPos)) mouse.position.copy(nextPos);

  // Tail follow animation
  tail.forEach((seg,i)=>{
    seg.position.z = -2.2 - i*0.6 + Math.sin(performance.now()*0.004 - i)*0.15;
  });

  // Camera follow
  camera.position.lerp(
    new THREE.Vector3(
      mouse.position.x - Math.sin(mouse.rotation.y)*12,
      10,
      mouse.position.z - Math.cos(mouse.rotation.y)*12
    ), 0.1
  );
  camera.lookAt(mouse.position);

  if (mouse.position.distanceTo(cheese.position) < 3) nextLevel();

  renderer.render(scene, camera);
}
animate();

addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
